#!/bin/sh

genindex() {
while getopts t: flag; do
	case $flag in
		t) template=$OPTARG;;
	esac
done
shift "$((OPTIND - 1))"

[ "$template" ] || template='
<li>
<b>{{Date}}:</b>
<a href="{{File}}">{{Name}}</a>
{{Extra}}
</li>
'

echo "<ul>"
recsel "${1:-/dev/stdin}" | recfmt "$template"
echo "</ul>"
}

injectindex() {
	genrss -i "$@"
}

genrss() {
while getopts t:u:d:i flag; do
	case $flag in
		t) title=$OPTARG;;
		u) url=$OPTARG;;
		d) description=$OPTARG;;
		i) inject=1;;
	esac
done
shift "$((OPTIND - 1))"

cat <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
<channel>
<title>${title:-Title}</title>
<link>${url:-url}</link>
<description>${description:-description}</description>
EOF

recsel "${1:-/dev/stdin}" | {
	# If the $inject variable is set, content will be added to the database
	# running through the pipline using sed and awk. If not, the contents
	# will be sent to cat, which hands it over without modification.
	[ "$inject" ] && {
		awk '
			/^File:.*\.html$/ {
				src = $0
				sub(/^File:\s\/?/, "", src)
				print "Contents:"
				print system("sed s/^/+/ " src) > "/dev/null"
			}
			
			{ print }
		'
	} || cat
} |
recfmt '
<item>
<title>{{Name}}</title>
<link>{{File}}</link>
<guid>{{File}}</guid>
<pubDate>{{Date}}</pubDate>
<description><![CDATA[
<a href="{{File}}">{{Name}}</a>
{{Extra}}
{{Contents}}
]]></description>
</item>
'

cat <<EOF
</channel>
</rss>
EOF
}

wraphtml() {
while getopts t:R: arg; do
	case $arg in
		t) template=$OPTARG;;
		R) regex=$OPTARG;;
		\?|*) exit 1;;
	esac
done
shift $(expr $OPTIND - 1)

sed "/${regex:-^\s*<!--WRAPHTML-->$}/r ${1:-/dev/stdin}" \
	"${template:-template.html}"
}

dirindex() {
while getopts s: flag; do
	case $flag in
		s) format=$OPTARG;;
	esac
done
shift "$((OPTIND - 1))"

for dir do
	find "$dir" -type f -printf "${format:-<li><a href=\"%p\">%p</a></li>\n}"
done
}

markdown2html() {
awk '
	# TODO: Paragraph tags.
	# TODO: Multiple of the same tag on the same line.
	# TODO: Formatting tags in lists and blockquotes.

	/^---$/ {
		print "<hr/>"; next
	}

	/\*\*.+\*\*/ { # Bold
		sub(/\*\*/, "<b>")
		sub(/\*\*/, "</b>")
	}

	/\*.+\*/ { # Italics
		sub(/\*/, "<i>")
		sub(/\*/, "</i>")
	}

	/`.+`/ { # Code
		sub(/`/, "<code>")
		sub(/`/, "</code>")
	}

	/^#{1,6}\s/ { # Headings
		hsize = "h" length($1)
		$1 = ""
		sub(/^\s/, "")
		printf "<%s>%s</%s>\n", hsize, $0, hsize
		next
	}

	/!\[[a-zA-Z ]+\]\(.+\)/ { # Images (figures)
		sub(/!\[/, "")
		sub(/]\(/, " ")
		sub(/)/, "")
		url=$NF
		$NF = ""
		sub(/\s$/, "")
		printf "<figure><img src=\"%s\" alt=\"%s\"/><figurecaption>%s</figurecaption></figure>\n", url, url, $0
		next
	}

	/\[[a-zA-Z ]+\]\(.+\)/ { # Urls
		sub(/\[/, "")
		sub(/]\(/, " ")
		sub(/)/, "")
		url=$NF
		$NF = ""
		sub(/\s$/, "")
		printf "<a href=\"%s\">%s</a>\n", url, $0
		next
	}

	/^[0-9]\.\s/ { # Ordered lists
		print "<ol>"
		while ($0 !~ /^$/) {
			$1=""
			sub(/^\s/, "")
			printf "<li>%s</li>\n", $0
			getline
		}
		print "</ol>"
	}

	/^[-*]\s/ { # Unordered lists
		print "<ul>"
		while ($0 !~ /^$/) {
			$1=""
			sub(/^\s/, "")
			printf "<li>%s</li>\n", $0
			getline
		}
		print "</ul>"
	}

	/^>\s/ { # Blockquotes
		print "<blockquote>"
		while ($0 !~ /^$/) {
			$1=""
			sub(/^\s/, "")
			print
			getline
		}
		print "</blockquote>"
	}

	{ print }
' < "${1:-/dev/stdin}"
}

relpath() {
for dir do
	find "$dir" -type f -name '*.html' |
	while read -r file; do
		grep "\(src\|href\)=[\"'][^/]" "$file" | grep -v "\(src\|href\)=[\"']\w\+://"
	done
done
}

gentoc() {
file=$(tr '\n' ' ' < "${1:-/dev/stdin}" | tr -d '\t' | grep -o '<h[1-6][^>]*>[^<]\+</h[1-6]>')
if [ -n "$file" ]; then
awk -F'</?h[1-6][^>]*>' '
	BEGIN {
		print "<ol class=\"toc\">"
		last_level = 1
	}

	{
		current_level = substr($0, 3, 1) # Get heading size (<hX>)
		if (! last_level) last_level = current_level
		diff_level = current_level - last_level

		if (diff_level != 0) {
			for (i = 0; i < diff_level; i++) print "<ol>"
			for (i = 0; i > diff_level; i--) print "</ol>"
		}
		printf "<li>%s</li>\n", $2
		last_level = current_level
	}

	END {
		for (i = 1; i < current_level; i++) print "</ol>"
		print "</ol>"
	}
' <<EOF
$file
EOF
fi
}
